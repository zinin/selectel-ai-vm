# playbooks/infra/gpu-start.yml
---
- name: Start GPU VM
  hosts: localhost
  connection: local
  gather_facts: true  # Нужно для ansible_date_time

  vars_files:
    - vars/main.yml

  vars:
    boot_disk_name: ""
    boot_image_name: ""
    # vm_name может быть переопределён через -e, иначе генерируется с timestamp
    flavor_id: "{{ gpu_flavor_id }}"

  tasks:
    # === Валидация входных данных ===
    - name: Validate boot source is provided
      ansible.builtin.fail:
        msg: "Specify either boot_disk_name or boot_image_name"
      when: boot_disk_name == "" and boot_image_name == ""

    - name: Validate boot source is exclusive
      ansible.builtin.fail:
        msg: "Specify either boot_disk_name or boot_image_name, not both"
      when: boot_disk_name != "" and boot_image_name != ""

    - name: Validate GPU_FLAVOR_ID is set
      ansible.builtin.fail:
        msg: "GPU_FLAVOR_ID must be set in .env"
      when: flavor_id == ""

    # === Генерация имени VM если не задано ===
    - name: Set default VM name with timestamp
      ansible.builtin.set_fact:
        vm_name: "{{ vm_name | default('gpu-vm-' + ansible_date_time.date | replace('-', '') + '-' + ansible_date_time.time | replace(':', '')) }}"

    # === Проверка уникальности имени VM ===
    - name: Check if VM with same name already exists
      openstack.cloud.server_info:
        server: "{{ vm_name }}"
      register: existing_vm

    - name: Fail if VM already exists
      ansible.builtin.fail:
        msg: "VM '{{ vm_name }}' already exists. Use different --name or delete existing VM."
      when: existing_vm.servers | length > 0

    # === SSH keypair с проверкой fingerprint ===
    - name: Read SSH public key
      ansible.builtin.set_fact:
        ssh_public_key: "{{ lookup('file', ssh_key_file | expanduser) }}"

    - name: Calculate local key fingerprint (MD5 format for OpenStack compatibility)
      ansible.builtin.shell: |
        set -o pipefail
        ssh-keygen -E md5 -lf {{ ssh_key_file | expanduser | quote }} | awk '{print $2}' | sed 's/^MD5://'
      args:
        executable: /bin/bash
      register: local_fingerprint
      changed_when: false

    - name: Get existing keypair info
      openstack.cloud.keypair_info:
        name: "{{ ssh_key_name }}"
      register: existing_keypair

    - name: Fail if keypair exists with different fingerprint
      ansible.builtin.fail:
        msg: >-
          Keypair '{{ ssh_key_name }}' exists with different fingerprint.
          Cloud: {{ existing_keypair.keypairs[0].fingerprint }}, Local: {{ local_fingerprint.stdout }}
      when: >
        existing_keypair.keypairs | length > 0 and
        existing_keypair.keypairs[0].fingerprint != local_fingerprint.stdout

    - name: Ensure keypair exists
      openstack.cloud.keypair:
        state: present
        name: "{{ ssh_key_name }}"
        public_key: "{{ ssh_public_key }}"
      when: existing_keypair.keypairs | length == 0

    # === Boot from existing disk ===
    - name: Get existing disk info
      openstack.cloud.volume_info:
        name: "{{ boot_disk_name }}"
      register: disk_info
      when: boot_disk_name != ""

    - name: Validate exactly one disk found
      ansible.builtin.fail:
        msg: "Expected exactly 1 disk named '{{ boot_disk_name }}', found {{ disk_info.volumes | length }}"
      when: boot_disk_name != "" and disk_info.volumes | length != 1

    - name: Validate disk is available (not in-use)
      ansible.builtin.fail:
        msg: "Disk '{{ boot_disk_name }}' is in-use (status: {{ disk_info.volumes[0].status }}). Detach it first."
      when: boot_disk_name != "" and disk_info.volumes | length == 1 and disk_info.volumes[0].status != 'available'

    - name: Create server from existing disk
      openstack.cloud.server:
        state: present
        name: "{{ vm_name }}"
        flavor: "{{ flavor_id }}"
        boot_volume: "{{ disk_info.volumes[0].id }}"
        terminate_volume: false
        key_name: "{{ ssh_key_name }}"
        security_groups:
          - "{{ security_group }}"
        networks:
          - name: "{{ network_name }}"
        availability_zone: "{{ availability_zone }}"
        auto_ip: false
        timeout: "{{ server_create_timeout }}"
        wait: true
      register: server_disk
      when: boot_disk_name != ""

    - name: Set server variable (disk branch)
      ansible.builtin.set_fact:
        server: "{{ server_disk }}"
      when: boot_disk_name != "" and server_disk.server is defined

    # === Boot from image (create new disk) ===
    - name: Get image info
      openstack.cloud.image_info:
        image: "{{ boot_image_name }}"
      register: image_info
      when: boot_image_name != ""

    - name: Validate exactly one image found
      ansible.builtin.fail:
        msg: "Expected exactly 1 image named '{{ boot_image_name }}', found {{ image_info.images | length }}"
      when: boot_image_name != "" and image_info.images | length != 1

    - name: Calculate disk size (max of default and image min_disk)
      ansible.builtin.set_fact:
        actual_disk_size: "{{ [default_disk_size | int, image_info.images[0].min_disk | default(0) | int] | max }}"
      when: boot_image_name != ""

    # Проверяем, что boot volume с таким именем не существует
    - name: Check if boot volume already exists
      openstack.cloud.volume_info:
        name: "{{ vm_name }}-boot"
      register: existing_boot_volume
      when: boot_image_name != ""

    - name: Fail if boot volume already exists
      ansible.builtin.fail:
        msg: "Boot volume '{{ vm_name }}-boot' already exists. Use different --name or delete existing volume."
      when: boot_image_name != "" and existing_boot_volume.volumes | length > 0

    # Используем block/rescue для отката тома при ошибке создания сервера
    - name: Create volume and server from image
      when: boot_image_name != ""
      block:
        - name: Create boot volume from image
          openstack.cloud.volume:
            state: present
            name: "{{ vm_name }}-boot"
            size: "{{ actual_disk_size }}"
            volume_type: "{{ default_disk_type }}"
            image: "{{ image_info.images[0].id }}"
            availability_zone: "{{ availability_zone }}"
            wait: true
          register: new_volume

        - name: Create server from new volume
          openstack.cloud.server:
            state: present
            name: "{{ vm_name }}"
            flavor: "{{ flavor_id }}"
            boot_volume: "{{ new_volume.volume.id }}"
            terminate_volume: false
            key_name: "{{ ssh_key_name }}"
            security_groups:
              - "{{ security_group }}"
            networks:
              - name: "{{ network_name }}"
            availability_zone: "{{ availability_zone }}"
            auto_ip: false
            timeout: "{{ server_create_timeout }}"
            wait: true
          register: server_image

        - name: Set server variable (image branch)
          ansible.builtin.set_fact:
            server: "{{ server_image }}"

      rescue:
        - name: Capture original error
          ansible.builtin.set_fact:
            original_error: "{{ ansible_failed_result.msg | default('Unknown error') }}"

        - name: Cleanup volume on server creation failure
          openstack.cloud.volume:
            state: absent
            name: "{{ vm_name }}-boot"
          when: new_volume.volume is defined
          failed_when: false

        - name: Fail with original error
          ansible.builtin.fail:
            msg: "Server creation failed: {{ original_error }}. Volume {{ vm_name }}-boot was cleaned up."

    # === Floating IP ===
    - name: Allocate floating IP
      openstack.cloud.floating_ip:
        state: present
        server: "{{ server.server.id }}"
        network: "{{ external_network }}"
        wait: true
      register: floating_ip
      when: allocate_floating_ip | bool

    # === Результат ===
    - name: Display server info
      ansible.builtin.debug:
        msg: |

          ========================================
          GPU VM Created Successfully!
          ========================================
          Name: {{ server.server.name }}
          ID: {{ server.server.id }}
          Status: {{ server.server.status }}
          Floating IP: {{ floating_ip.floating_ip.floating_ip_address if floating_ip is defined and floating_ip.floating_ip is defined else 'not allocated' }}

          Connect: ssh root@{{ floating_ip.floating_ip.floating_ip_address
            if floating_ip is defined and floating_ip.floating_ip is defined else '<floating_ip>' }}
          ========================================
